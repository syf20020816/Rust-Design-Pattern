//! # Stack栈
//! 后进先出
//! ```code
//!     |    |
//!     | *4 | ←— 栈顶指针
//!     | *3 |
//!     | *2 |
//!     | *1 |
//!     |————|
//! ```
//! ## 常用方法
//! 1. new:初始化空栈
//! 2. is_empty:是否为空栈
//! 3. push:入栈
//! 4. pop:出栈
//! 5. peek:获取栈顶元素
//!
//! ## 场景
//! 1. 函数调用：栈用于存储函数调用的上下文和局部变量。当一个函数被调用时，其上下文（如返回地址、参数、局部变量等）被压入栈中，当函数执行完毕后，这些上下文被弹出，程序继续执行调用该函数的位置。
//! 2. 表达式求值：在编译器或解释器中，栈用于处理数学表达式的求值。通过将操作数和运算符压入栈中，并按照运算符的优先级进行计算，可以从栈顶弹出结果。
//! 3. 内存管理：栈在内存管理中起到重要作用。程序中的局部变量和临时数据通常存储在栈上，通过在栈上分配和释放内存，可以高效地管理内存空间。
//! 4. 后退按钮：Web浏览器和应用程序中的后退按钮通常使用栈来记录用户导航历史。每当用户浏览新页面时，当前页面的信息被推入栈中，这样用户可以按下后退按钮并逐步回退到之前的页面。
//! 5. 撤销操作：图形设计软件、文本编辑器等应用程序通常使用栈来实现撤销（undo）操作。每次用户进行修改时，将修改前的状态存储在栈中，可以通过弹出栈顶元素来撤销最后的操作。
//! 6. 括号匹配：栈用于检查括号是否匹配。当遇到左括号时，将其压入栈中；当遇到右括号时，检查栈顶元素是否为对应的左括号，并将其弹出。如果最后栈为空，则说明所有括号都匹配。
//!
//! ## 限定栈深度（引出：扩容）
//! 可以通过设置一个容量来限定栈的深度，此时可以动态传入栈的容量，当容量低于三分之一时考虑扩容
//! ```txt
//! @author:syf20020816@Outlook.com
//! @date:2023/8/10
//! @version:0.0.1
//! @description:
//! ```
#[derive(Debug)]
pub struct Stack<T>{
    pointer:isize,
    data:Vec<T>
}

impl<T> Stack<T>{
    /// # 初始化空栈
    pub fn new()->Self{
        Stack{
            pointer: -1,
            data: vec![]
        }
    }
    /// # 判断栈是否为空
    /// 一行代码足够了
    /// 1. 判断栈顶指针是否为-1
    /// 2. 判断栈中数据是否为0
    pub fn is_empty(&self)->bool{
        isize::from(-1 as isize).eq(&self.pointer) && 0.eq(&self.data.len())
    }
    /// # 入栈
    /// 1. 栈顶指针上移1位
    /// 2. 元素入vec
    pub fn push(&mut self,el:T)->(){
        self.pointer+=1;
        self.data.push(el);
    }
    /// # 出栈
    /// 1. 判断是否为空栈
    /// 2. 栈顶指针下移一位
    /// 3. data去除元素
    pub fn pop(&mut self)->T{
        if self.is_empty() {
            panic!("empty")
        }else {
            self.pointer-=1;
            match self.data.pop() {
                None =>  panic!("empty"),
                Some(res) => res
            }
        }
    }
    /// # 获取栈顶元素
    pub fn peek(&self)->&T{
        if self.is_empty() {
            panic!("empty")
        }else {
            &self.data[self.pointer as usize]
        }
    }
}
