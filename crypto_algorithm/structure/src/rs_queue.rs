//! # 队列Queue结构
//! 先进先出的结构
//! ## 结构
//! ```code
//!       ——————————————————————————————————
//! 对首→  *1 | *2 | *3 | *4 | *5 | *6 | *7    ←队尾
//!       ——————————————————————————————————
//!       ↳              容量               ↲
//! ```
//! ## 方法
//! 1. new:初始化队列
//! 2. push:入队
//! 3. pop:出队
//! 4. is_empty:是否空队
//! 5. len:队列长度
//! ## 场景
//!
//!1. 任务调度：队列可以用于任务调度和处理。当有多个任务需要执行时，可以将这些任务排列在队列中，按照先进先出的顺序逐个执行。
//!2. 消息传递：队列常用于实现消息传递系统。发送方将消息放入队列中，接收方按照先进先出的顺序从队列中取出消息进行处理。
//!3. 广播通知：队列可以用于实现广播通知机制。当某个事件发生时，可以将相关的通知放入队列中，然后让感兴趣的订阅者从队列中获取通知。
//!4. 缓冲区：队列常用作缓冲区，用于存储待处理的数据。当处理速度和输入速度不一致时，可以使用队列作为缓冲区来平衡两者之间的差异。
//!5. 线程同步：在多线程编程中，队列可以用于线程间的安全数据传递和同步。一个线程可以将数据放入队列中，而另一个线程可以从队列中获取数据进行处理。
//!6. 消费者-生产者模式：队列常用于实现消费者-生产者模式。生产者将数据放入队列中，而消费者从队列中获取数据进行处理，实现了解耦和并发处理。
//!7. 网络请求管理：在网络编程中，队列可以用于管理待发送的网络请求。将待发送的请求放入队列中，然后由网络模块按照先进先出的顺序发送请求，确保请求的有序性和公平性。
//!
//! ```txt
//! @author:syf20020816@Outlook.com
//! @date:2023/8/10
//! @version:0.0.1
//! @description:
//! ```
#[derive(Debug)]
pub struct Queue<T>{
    data:Vec<T>,
    len:usize
}

impl<T> Queue<T> {
    /// # 创建一个空队列
    /// 队列容量由调用者传入
    /// 限定了队列长度，所以使用with_capacity
    pub fn new(len:usize)->Self{
        Queue{
            data:Vec::with_capacity(len),
            len
        }
    }
    /// # 队列长度
    pub fn len(&self)->usize{
        self.data.len()
    }
    /// # 是否空队
    pub fn is_empty(&self)->bool{
        0_usize.eq(&self.len())
    }
    /// # 入队
    /// 1. 判断队列长度是否==容量(队满)
    /// 2. 入队
    pub fn push(&mut self,el:T)->(){
        if self.len().lt(&self.len) {
            self.data.push(el);
        }
    }
    /// # 出队
    /// 1. 判断队列是否为空
    /// 2. 出队(需要注意的是，出队是从队首出的)
    pub fn pop(&mut self)->T{
        if self.is_empty() {
            panic!("empty")
        }else {
            self.data.remove(0)
        }
    }
}