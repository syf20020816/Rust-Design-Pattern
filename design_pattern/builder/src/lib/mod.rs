//!# 建造者模式
//!
//! 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示
//!
//! - 分离了部件的构造(由Builder来负责)和装配(由Director负责) 从而可以构造出复杂的对象。这个模式适用于:某个对象的构建过程复杂的情况。
//! - 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象;相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
//! - 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。
//!
//! ## 建造者模式中的角色
//!
//! 1. 抽象建造者类(Builder):这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建。
//! 2. 具体建造者类(ConcreteBuilder)︰实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。
//! 3. 产品类(Product):要创建的复杂对象。
//! 4. 指挥者类(Director)︰调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。
//!
//! ## 优点
//!
//! 1. 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性
//! 2. 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
//! 3. 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
//! 4. 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。
//!
//! ## 缺点
//!
//! 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
//!
//! ## 使用场合
//!
//! 1. 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的
//! 2. 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的
//! ```txt
//! @author:syf20020816@Outlook.com
//! @date:2023/8/8
//! @version:0.0.1
//! @description:
//! ```
pub mod simple_builder;
pub mod flex_builder;

/// 具体产品
#[derive(Debug)]
pub struct Computer {
    screen: String,
    battery: String,
    mouse: String,
}

impl Computer {
    pub fn new()->Computer{
        Computer {
            screen: "".to_string(),
            battery: "".to_string(),
            mouse: "".to_string(),
        }
    }
    pub fn set_screen(&mut self, name: &str) -> () {
        self.screen = String::from(name);
    }
    pub fn set_battery(&mut self, name: &str) -> () {
        self.battery = String::from(name);
    }
    pub fn set_mouse(&mut self, name: &str) -> () {
        self.mouse = String::from(name);
    }
}
